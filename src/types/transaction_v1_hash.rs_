use super::digest::Digest;
use crate::debug::error;
use casper_types::Digest as _Digest;
use casper_types::TransactionV1Hash as _TransactionV1Hash;
#[cfg(target_arch = "wasm32")]
use gloo_utils::format::JsValueSerdeExt;
use hex::decode;
use serde::{Deserialize, Serialize};
use std::fmt;
use wasm_bindgen::prelude::*;

#[derive(Debug, Deserialize, Clone, Serialize)]
#[wasm_bindgen]
pub struct TransactionV1Hash(_TransactionV1Hash);

#[wasm_bindgen]
impl TransactionV1Hash {
    #[wasm_bindgen(constructor)]
    pub fn new(transaction_hash_hex_str: &str) -> Result<TransactionV1Hash, JsValue> {
        let bytes = decode(transaction_hash_hex_str)
            .map_err(|err| error(&format!("{:?}", err)))
            .unwrap();
        let mut hash = [0u8; _Digest::LENGTH];
        hash.copy_from_slice(&bytes);
        Self::from_digest(Digest::from(hash))
    }

    #[wasm_bindgen(js_name = "fromDigest")]
    pub fn from_digest(digest: Digest) -> Result<TransactionV1Hash, JsValue> {
        Ok(_TransactionV1Hash::new(digest.into()).into())
    }

    #[wasm_bindgen(js_name = "fromRaw")]
    pub fn from_raw(raw_digest: &[u8]) -> Result<TransactionV1Hash, JsValue> {
        if raw_digest.len() != _Digest::LENGTH {
            return Err(JsValue::from_str("Invalid digest length"));
        }
        let mut array = [0u8; _Digest::LENGTH];
        array.copy_from_slice(raw_digest);
        Ok(TransactionV1Hash(_TransactionV1Hash::from_raw(array)).into())
    }

    #[cfg(target_arch = "wasm32")]
    #[wasm_bindgen(js_name = "toJson")]
    pub fn to_json(&self) -> JsValue {
        JsValue::from_serde(self).unwrap_or(JsValue::null())
    }

    #[cfg(target_arch = "wasm32")]
    #[wasm_bindgen(js_name = "toString")]
    pub fn to_string_js_alias(&self) -> String {
        self.to_string()
    }
}

impl fmt::Display for TransactionV1Hash {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", hex::encode(self.0))
    }
}

impl From<TransactionV1Hash> for _TransactionV1Hash {
    fn from(transaction_hash: TransactionV1Hash) -> Self {
        transaction_hash.0
    }
}

impl From<_TransactionV1Hash> for TransactionV1Hash {
    fn from(transaction_hash: _TransactionV1Hash) -> Self {
        TransactionV1Hash(transaction_hash)
    }
}

impl From<Digest> for TransactionV1Hash {
    fn from(digest: Digest) -> Self {
        _TransactionV1Hash::new(digest.into()).into()
    }
}
